{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"biliresp Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, examples for validating dipoles, and a mass-weighted center-of-mass calculator that can operate on RESP or xyz geometries. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges (and reconciling centers of mass) using the helper in scripts/print_dipoles.py or the reference implementation in tests/test_dipole.py .","title":"Home"},{"location":"#biliresp","text":"Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, examples for validating dipoles, and a mass-weighted center-of-mass calculator that can operate on RESP or xyz geometries. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges (and reconciling centers of mass) using the helper in scripts/print_dipoles.py or the reference implementation in tests/test_dipole.py .","title":"biliresp"},{"location":"getting-started/","text":"Getting Started Prerequisites Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate Install the package Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e . Run the test suite Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate","title":"Prerequisites"},{"location":"getting-started/#install-the-package","text":"Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e .","title":"Install the package"},{"location":"getting-started/#run-the-test-suite","text":"Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Run the test suite"},{"location":"symmetry/","text":"Symmetry Analysis The symmetry module converts molecular structures into networkx graphs and applies Weisfeiler\u2013Lehman (WL) refinement to discover atoms that share identical local environments. This is particularly helpful when analysing RESP results, because the buckets returned by the WL procedure highlight atoms that can share constrained charges. from pathlib import Path from symmetry import buckets_from_pdb buckets = buckets_from_pdb(Path(\"data/raw/1.pose.pdb\"), radius=10) print(f\"Identified {len(buckets)} equivalence classes\") Each bucket contains the indices of atoms that are indistinguishable after r rounds of WL refinement. Increase radius when you need a deeper comparison of atomic environments. Hydrogen-less molecular network used for WL refinement. Radius 10 Radius 15 The figure above starts from the hydrogen-less network of the biliverdin fragment. The colourings correspond to WL buckets evaluated at radii 10 and 15, respectively.","title":"Symmetry Index"},{"location":"symmetry/#symmetry-analysis","text":"The symmetry module converts molecular structures into networkx graphs and applies Weisfeiler\u2013Lehman (WL) refinement to discover atoms that share identical local environments. This is particularly helpful when analysing RESP results, because the buckets returned by the WL procedure highlight atoms that can share constrained charges. from pathlib import Path from symmetry import buckets_from_pdb buckets = buckets_from_pdb(Path(\"data/raw/1.pose.pdb\"), radius=10) print(f\"Identified {len(buckets)} equivalence classes\") Each bucket contains the indices of atoms that are indistinguishable after r rounds of WL refinement. Increase radius when you need a deeper comparison of atomic environments. Hydrogen-less molecular network used for WL refinement. Radius 10 Radius 15 The figure above starts from the hydrogen-less network of the biliverdin fragment. The colourings correspond to WL buckets evaluated at radii 10 and 15, respectively.","title":"Symmetry Analysis"},{"location":"workflows/dipole-cross-validation/","text":"Dipole Cross-Validation The helper implemented in scripts/print_dipoles.py (and mirrored inside tests/test_dipole.py ) compares three sets of dipole moments for a selected frame of a RESP run: QM dipole reported directly by TeraChem. TeraChem dipole reconstructed from the ESP-unrestrained charges written in resp.out . Lagrange dipole generated from the fitted charges returned by the linear ESP solver. The helper parses the frame in resp.out , converts the logged center of mass to bohr, and computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It also reports a mass-weighted center of mass derived from the supplied geometry .xyz file; you can override the coordinates (\u00c5 or bohr) when calling center_of_mass_bohr_from_xyz if you need to reuse RESP geometries directly. The return dictionary contains each dipole vector/magnitude, their deltas relative to the QM reference, and both COM estimates. Script entry point scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz data/raw/1.pose.xyz 78 --frame -1 The script builds the linear system, fits charges with the explicit Lagrange projection, and prints the QM, TeraChem, and Lagrange dipoles plus their deltas. --frame chooses which RESP frame to analyze ( -1 = last). The geometry .xyz supplies element ordering for mass lookup when computing the mass-weighted COM. Typical output QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 Terachem charges (RESP log) vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Lagrange multiplier fit (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows. Parity visualisation The example notebook in notebooks/ produces a parity plot comparing the QM dipole magnitude against the TeraChem ESP reconstruction across every frame. The figure below highlights the excellent agreement and annotates the RMSE. Colours denote the absolute deviation |\u0394| in Debye. Programmatic use See tests/test_dipole.py for a complete, importable example. The test implements _three_dipoles_for_frame inline so you can copy it into your own workflow if the CLI output is not sufficient.","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#dipole-cross-validation","text":"The helper implemented in scripts/print_dipoles.py (and mirrored inside tests/test_dipole.py ) compares three sets of dipole moments for a selected frame of a RESP run: QM dipole reported directly by TeraChem. TeraChem dipole reconstructed from the ESP-unrestrained charges written in resp.out . Lagrange dipole generated from the fitted charges returned by the linear ESP solver. The helper parses the frame in resp.out , converts the logged center of mass to bohr, and computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It also reports a mass-weighted center of mass derived from the supplied geometry .xyz file; you can override the coordinates (\u00c5 or bohr) when calling center_of_mass_bohr_from_xyz if you need to reuse RESP geometries directly. The return dictionary contains each dipole vector/magnitude, their deltas relative to the QM reference, and both COM estimates.","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#script-entry-point","text":"scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz data/raw/1.pose.xyz 78 --frame -1 The script builds the linear system, fits charges with the explicit Lagrange projection, and prints the QM, TeraChem, and Lagrange dipoles plus their deltas. --frame chooses which RESP frame to analyze ( -1 = last). The geometry .xyz supplies element ordering for mass lookup when computing the mass-weighted COM.","title":"Script entry point"},{"location":"workflows/dipole-cross-validation/#typical-output","text":"QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 Terachem charges (RESP log) vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Lagrange multiplier fit (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows.","title":"Typical output"},{"location":"workflows/dipole-cross-validation/#parity-visualisation","text":"The example notebook in notebooks/ produces a parity plot comparing the QM dipole magnitude against the TeraChem ESP reconstruction across every frame. The figure below highlights the excellent agreement and annotates the RMSE. Colours denote the absolute deviation |\u0394| in Debye.","title":"Parity visualisation"},{"location":"workflows/dipole-cross-validation/#programmatic-use","text":"See tests/test_dipole.py for a complete, importable example. The test implements _three_dipoles_for_frame inline so you can copy it into your own workflow if the CLI output is not sufficient.","title":"Programmatic use"},{"location":"workflows/esp-charge-distributions/","text":"ESP Charge Distributions The notebook in notebooks/ that accompanies this project aggregates the ESP-unrestrained charges from every frame in resp.out . Two views are especially useful when sanity-checking how individual atoms sample the RESP charge distribution throughout a trajectory. Per-atom histograms The figure below overlays the histograms for every nitrogen (blue tones) and oxygen (orange tones) atom. Each trace corresponds to one atom index, so you can spot outliers or unusually broad distributions at a glance. The compact support and narrow widths suggest that the ESP-unrestrained fit is stable across the frames considered. Gaussian fits The same notebook fits a normal distribution to each atom\u2019s samples and overlays the resulting curves. This makes it easy to compare the mean and spread across similar atoms. The legend in the notebook lists the fitted mean (\u03bc) and standard deviation (\u03c3) for each atom, providing quick access to quantitative summaries that can be reused in downstream analyses.","title":"ESP Charge Distributions"},{"location":"workflows/esp-charge-distributions/#esp-charge-distributions","text":"The notebook in notebooks/ that accompanies this project aggregates the ESP-unrestrained charges from every frame in resp.out . Two views are especially useful when sanity-checking how individual atoms sample the RESP charge distribution throughout a trajectory.","title":"ESP Charge Distributions"},{"location":"workflows/esp-charge-distributions/#per-atom-histograms","text":"The figure below overlays the histograms for every nitrogen (blue tones) and oxygen (orange tones) atom. Each trace corresponds to one atom index, so you can spot outliers or unusually broad distributions at a glance. The compact support and narrow widths suggest that the ESP-unrestrained fit is stable across the frames considered.","title":"Per-atom histograms"},{"location":"workflows/esp-charge-distributions/#gaussian-fits","text":"The same notebook fits a normal distribution to each atom\u2019s samples and overlays the resulting curves. This makes it easy to compare the mean and spread across similar atoms. The legend in the notebook lists the fitted mean (\u03bc) and standard deviation (\u03c3) for each atom, providing quick access to quantitative summaries that can be reused in downstream analyses.","title":"Gaussian fits"},{"location":"workflows/linear-esp-solver/","text":"Linear ESP Charge Solver The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy. Pipeline Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q with explicit_solution , a closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). It accepts an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability. Script entry point The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality. Mathematical derivation The objective is to minimise the grid misfit while enforcing the desired total charge: \\[ \\begin{aligned} \\min_{q}\\ & \\frac{1}{2}\\lVert A q - V \\rVert_2^2 \\\\ \\text{s.t.}\\ & \\mathbf{1}^\\top q = Q. \\end{aligned} \\] Using the Lagrangian \\(\\mathcal{L}(q, \\lambda) = \\tfrac{1}{2}\\lVert A q - V \\rVert_2^2 + \\lambda (\\mathbf{1}^\\top q - Q)\\) gives the stationary conditions \\[ \\nabla_q \\mathcal{L} = A^\\top(Aq - V) + \\lambda\\,\\mathbf{1} = 0,\\qquad \\nabla_\\lambda \\mathcal{L} = \\mathbf{1}^\\top q - Q = 0. \\] Defining \\(H = A^\\top A\\) and \\(g = A^\\top V\\) leads to the Karush\u2013Kuhn\u2013Tucker system \\[ \\begin{pmatrix} H & \\mathbf{1} \\\\ \\mathbf{1}^\\top & 0 \\end{pmatrix} \\begin{pmatrix} q \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} g \\\\ Q \\end{pmatrix}. \\] Rather than solving the \\((N+1)\\times(N+1)\\) block system directly, the implementation projects the unconstrained least-squares solution onto the charge-conserving hyperplane: Solve \\(H q_0 = g\\) to obtain the unconstrained solution ( q0 ). Solve \\(H c = \\mathbf{1}\\) for the correction direction ( c ). Compute \\(\\alpha = \\mathbf{1}^\\top c\\) and \\(s = \\mathbf{1}^\\top q_0\\) . Project: \\(q = q_0 - \\frac{s - Q}{\\alpha}\\, c\\) . If numerical damping is requested, \\(H\\) is replaced with \\(H + \\eta I\\) (with a small \\(\\eta > 0\\) ) in the two linear solves above. The procedure yields the same result as the full KKT solve but avoids explicitly forming the block matrix. Programmatic use You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Linear ESP Solver"},{"location":"workflows/linear-esp-solver/#linear-esp-charge-solver","text":"The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy.","title":"Linear ESP Charge Solver"},{"location":"workflows/linear-esp-solver/#pipeline","text":"Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q with explicit_solution , a closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). It accepts an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability.","title":"Pipeline"},{"location":"workflows/linear-esp-solver/#script-entry-point","text":"The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality.","title":"Script entry point"},{"location":"workflows/linear-esp-solver/#mathematical-derivation","text":"The objective is to minimise the grid misfit while enforcing the desired total charge: \\[ \\begin{aligned} \\min_{q}\\ & \\frac{1}{2}\\lVert A q - V \\rVert_2^2 \\\\ \\text{s.t.}\\ & \\mathbf{1}^\\top q = Q. \\end{aligned} \\] Using the Lagrangian \\(\\mathcal{L}(q, \\lambda) = \\tfrac{1}{2}\\lVert A q - V \\rVert_2^2 + \\lambda (\\mathbf{1}^\\top q - Q)\\) gives the stationary conditions \\[ \\nabla_q \\mathcal{L} = A^\\top(Aq - V) + \\lambda\\,\\mathbf{1} = 0,\\qquad \\nabla_\\lambda \\mathcal{L} = \\mathbf{1}^\\top q - Q = 0. \\] Defining \\(H = A^\\top A\\) and \\(g = A^\\top V\\) leads to the Karush\u2013Kuhn\u2013Tucker system \\[ \\begin{pmatrix} H & \\mathbf{1} \\\\ \\mathbf{1}^\\top & 0 \\end{pmatrix} \\begin{pmatrix} q \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} g \\\\ Q \\end{pmatrix}. \\] Rather than solving the \\((N+1)\\times(N+1)\\) block system directly, the implementation projects the unconstrained least-squares solution onto the charge-conserving hyperplane: Solve \\(H q_0 = g\\) to obtain the unconstrained solution ( q0 ). Solve \\(H c = \\mathbf{1}\\) for the correction direction ( c ). Compute \\(\\alpha = \\mathbf{1}^\\top c\\) and \\(s = \\mathbf{1}^\\top q_0\\) . Project: \\(q = q_0 - \\frac{s - Q}{\\alpha}\\, c\\) . If numerical damping is requested, \\(H\\) is replaced with \\(H + \\eta I\\) (with a small \\(\\eta > 0\\) ) in the two linear solves above. The procedure yields the same result as the full KKT solve but avoids explicitly forming the block matrix.","title":"Mathematical derivation"},{"location":"workflows/linear-esp-solver/#programmatic-use","text":"You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Programmatic use"},{"location":"workflows/resp-hyperbolic-solver/","text":"RESP Hyperbolic Solver The RESP workflow augments the linear ESP fit with a nonlinear, hyperbolic restraint that mirrors the setup used by TeraChem. All routines live in resp.resp , with fit_resp_charges acting as the main entry point. Objective and Restraint Given a design matrix \\(A \\in \\mathbb{R}^{M \\times N}\\) , ESP grid values \\(V \\in \\mathbb{R}^{M}\\) , and a target total charge \\(Q\\) , we minimise the penalised loss \\[ \\mathcal{L}(q) = \\|A q - V\\|_2^2 + R(q), \\] subject to charge conservation \\[ \\mathbf{1}^\\top q = Q. \\] The restraint couples to a mask \\(m \\in \\{0,1\\}^N\\) that selects which atoms participate (all atoms by default): \\[ R(q) = a \\sum_{i: m_i = 1} \\left(\\sqrt{(q_i - q_0)^2 + b^2} - b\\right). \\] Parameters \\((a, b, q_0)\\) form the HyperbolicRestraint . The gradient needed for optimisation is \\[ \\frac{\\partial R}{\\partial q_i} = \\begin{cases} a\\,\\dfrac{q_i - q_0}{\\sqrt{(q_i - q_0)^2 + b^2}}, & m_i = 1,\\\\[1.2ex] 0, & m_i = 0. \\end{cases} \\] KKT System Introducing a Lagrange multiplier \\(\\lambda\\) for the charge constraint yields the first-order optimality conditions \\[ \\nabla_q \\mathcal{L}(q) + \\lambda \\mathbf{1} = 0, \\qquad \\mathbf{1}^\\top q - Q = 0, \\] where \\(\\nabla_q \\mathcal{L}(q) = 2 A^\\top (A q - V) + \\nabla R(q)\\) . Stacking the unknowns into \\(x = (q, \\lambda)\\) gives a nonlinear system \\[ F(x) = \\begin{bmatrix} 2 A^\\top (A q - V) + \\nabla R(q) + \\lambda \\mathbf{1} \\\\ \\mathbf{1}^\\top q - Q \\end{bmatrix} = 0. \\] Newton\u2013Krylov Solve fit_resp_charges calls SciPy's newton_krylov on \\(F(x)\\) . The solver uses an initial guess \\((q^{(0)}, \\lambda^{(0)})\\) built from the linear ESP solution and zero Lagrange multiplier. Each iteration: Evaluates \\(F(x)\\) and numerically approximates the Jacobian\u2013vector product. Solves for a correction using a Krylov subspace method. Updates \\(x\\) with the computed Newton step. No line search is performed, so the loss history can oscillate slightly before convergence. Convergence is declared when the infinity norm of \\(F(x)\\) drops below the requested tolerance. Diagnostics and Outputs The returned dictionary includes the fitted charges, Lagrange multiplier, loss breakdown ( loss , ls_term , restraint ), RMSE/RRMS, total charge information, the boolean restraint mask, and the running loss_history . _loss_terms evaluates the same objective outside the solver loop and is reused by the public API for consistency. kkt_residual_at re-computes \\(F(x)\\) for any charge vector, making it easy to compare against reference data such as TeraChem outputs or to audit convergence criteria. plot_loss_history visualises loss_history . If notebooks/prl.mplstyle exists, it is applied automatically to keep project plots consistent; otherwise the Matplotlib defaults are used. Masking Behaviour By default every atom is restrained. Passing restrain_all_atoms=False selects only heavy atoms, reproducing the legacy RESP convention. The solver stores the mask used in the mask entry of the result bundle. Usage Example from pathlib import Path from resp.resp import HyperbolicRestraint, fit_resp_charges resp_out = Path(\"data/raw/resp.out\") esp_xyz = Path(\"data/raw/esp.xyz\") geometry_xyz = Path(\"data/raw/1.pose.xyz\") restraint = HyperbolicRestraint(a=5e-4, b=1e-3, q0=0.0) result = fit_resp_charges( resp_out, esp_xyz, geometry_xyz, number_of_atoms=78, frame_index=-1, restraint=restraint, restrain_all_atoms=True, save_loss_plot=True, ) print(result[\"loss\"], result[\"sum_q\"]) This mirrors the workflow exercised in tests/test_resp_solver.py , where the fitted charges match the final RESP frame from TeraChem to within \\(10^{-5}\\) .","title":"RESP Hyperbolic Solver"},{"location":"workflows/resp-hyperbolic-solver/#resp-hyperbolic-solver","text":"The RESP workflow augments the linear ESP fit with a nonlinear, hyperbolic restraint that mirrors the setup used by TeraChem. All routines live in resp.resp , with fit_resp_charges acting as the main entry point.","title":"RESP Hyperbolic Solver"},{"location":"workflows/resp-hyperbolic-solver/#objective-and-restraint","text":"Given a design matrix \\(A \\in \\mathbb{R}^{M \\times N}\\) , ESP grid values \\(V \\in \\mathbb{R}^{M}\\) , and a target total charge \\(Q\\) , we minimise the penalised loss \\[ \\mathcal{L}(q) = \\|A q - V\\|_2^2 + R(q), \\] subject to charge conservation \\[ \\mathbf{1}^\\top q = Q. \\] The restraint couples to a mask \\(m \\in \\{0,1\\}^N\\) that selects which atoms participate (all atoms by default): \\[ R(q) = a \\sum_{i: m_i = 1} \\left(\\sqrt{(q_i - q_0)^2 + b^2} - b\\right). \\] Parameters \\((a, b, q_0)\\) form the HyperbolicRestraint . The gradient needed for optimisation is \\[ \\frac{\\partial R}{\\partial q_i} = \\begin{cases} a\\,\\dfrac{q_i - q_0}{\\sqrt{(q_i - q_0)^2 + b^2}}, & m_i = 1,\\\\[1.2ex] 0, & m_i = 0. \\end{cases} \\]","title":"Objective and Restraint"},{"location":"workflows/resp-hyperbolic-solver/#kkt-system","text":"Introducing a Lagrange multiplier \\(\\lambda\\) for the charge constraint yields the first-order optimality conditions \\[ \\nabla_q \\mathcal{L}(q) + \\lambda \\mathbf{1} = 0, \\qquad \\mathbf{1}^\\top q - Q = 0, \\] where \\(\\nabla_q \\mathcal{L}(q) = 2 A^\\top (A q - V) + \\nabla R(q)\\) . Stacking the unknowns into \\(x = (q, \\lambda)\\) gives a nonlinear system \\[ F(x) = \\begin{bmatrix} 2 A^\\top (A q - V) + \\nabla R(q) + \\lambda \\mathbf{1} \\\\ \\mathbf{1}^\\top q - Q \\end{bmatrix} = 0. \\]","title":"KKT System"},{"location":"workflows/resp-hyperbolic-solver/#newtonkrylov-solve","text":"fit_resp_charges calls SciPy's newton_krylov on \\(F(x)\\) . The solver uses an initial guess \\((q^{(0)}, \\lambda^{(0)})\\) built from the linear ESP solution and zero Lagrange multiplier. Each iteration: Evaluates \\(F(x)\\) and numerically approximates the Jacobian\u2013vector product. Solves for a correction using a Krylov subspace method. Updates \\(x\\) with the computed Newton step. No line search is performed, so the loss history can oscillate slightly before convergence. Convergence is declared when the infinity norm of \\(F(x)\\) drops below the requested tolerance.","title":"Newton\u2013Krylov Solve"},{"location":"workflows/resp-hyperbolic-solver/#diagnostics-and-outputs","text":"The returned dictionary includes the fitted charges, Lagrange multiplier, loss breakdown ( loss , ls_term , restraint ), RMSE/RRMS, total charge information, the boolean restraint mask, and the running loss_history . _loss_terms evaluates the same objective outside the solver loop and is reused by the public API for consistency. kkt_residual_at re-computes \\(F(x)\\) for any charge vector, making it easy to compare against reference data such as TeraChem outputs or to audit convergence criteria. plot_loss_history visualises loss_history . If notebooks/prl.mplstyle exists, it is applied automatically to keep project plots consistent; otherwise the Matplotlib defaults are used.","title":"Diagnostics and Outputs"},{"location":"workflows/resp-hyperbolic-solver/#masking-behaviour","text":"By default every atom is restrained. Passing restrain_all_atoms=False selects only heavy atoms, reproducing the legacy RESP convention. The solver stores the mask used in the mask entry of the result bundle.","title":"Masking Behaviour"},{"location":"workflows/resp-hyperbolic-solver/#usage-example","text":"from pathlib import Path from resp.resp import HyperbolicRestraint, fit_resp_charges resp_out = Path(\"data/raw/resp.out\") esp_xyz = Path(\"data/raw/esp.xyz\") geometry_xyz = Path(\"data/raw/1.pose.xyz\") restraint = HyperbolicRestraint(a=5e-4, b=1e-3, q0=0.0) result = fit_resp_charges( resp_out, esp_xyz, geometry_xyz, number_of_atoms=78, frame_index=-1, restraint=restraint, restrain_all_atoms=True, save_loss_plot=True, ) print(result[\"loss\"], result[\"sum_q\"]) This mirrors the workflow exercised in tests/test_resp_solver.py , where the fitted charges match the final RESP frame from TeraChem to within \\(10^{-5}\\) .","title":"Usage Example"},{"location":"workflows/twostep-resp/","text":"Two-Step RESP Workflow The two-step RESP pipeline reproduces the AMBER-style restrained electrostatic potential fit used by the TeraChem DYES protocol.[^amber-dyes] It applies the Weisfeiler\u2013Lehman symmetry buckets computed for each microstate, enforces total and bucket-specific charge constraints, and reruns a second RESP optimisation that selectively relaxes atoms flagged in project-specific masks. Stages at a Glance Linear warm start \u2013 solve_least_squares_with_constraints (in twostepresp.tsresp ) fits bucket charges that satisfy the aggregate constraints and provides an initial KKT solution. Step-one RESP \u2013 resp_step runs a Newton\u2013Krylov solve with the hyperbolic restraint active on the mask defined in mask_step_1.yaml , producing step1 charges for every configuration. Step-two RESP \u2013 The solver reuses converged bucket charges but frees the subset flagged in mask_step_2.yaml , recomputing the fit while holding the remaining buckets fixed. The result is stored as step2 , our recommended production charge set. Both RESP steps log the KKT residual, gradient norm, and the charge vector, matching the diagnostics in resp.resp . Command-Line Entry Point scripts/generate_twostep_resp.py batches the workflow across all TeraChem configurations in a microstate directory: python scripts/generate_twostep_resp.py \\ --microstate-root data/microstates/PPP \\ --maxiter 400 The script automatically: Loads symmetry-buckets/r8.dat to build the expansion matrix. Reads total and bucket charge constraints from charge-contraints/ . Applies step-one and step-two masks from YAML templates co-located in the microstate root. Persists labels (configuration stems), step1 , and step2 matrices to twostepRESP/charges.npz . Use --dry-run to list the configuration stems without running RESP, or --max-configs to limit the number of fits during debugging. Retrying a Single Configuration scripts/retry_twostep_resp.py mirrors the batch workflow for a single stem: python scripts/retry_twostep_resp.py \\ --microstate-root data/microstates/PPP \\ --config conf2371 \\ --step1-maxiter 120 \\ --step2-maxiter 240 \\ --show-charges The retrier reuses the masks, symmetry buckets, and constraints from the batch script, but exposes separate iteration limits for each stage and can print the atom-wise charges, making it ideal for diagnosing non-convergent fits. Consuming the Results The resulting NPZ files provide configuration-major charge matrices. Pair them with the atom labels from the raw ESP workflow to slice by atom type, compare against single-step RESP, or feed into downstream notebooks such as notebooks/twostepRESP.ipynb . Because step2 aligns with the AMBER two-stage procedure, it should be used as the primary source for production charge analyses unless diagnostics show step-two convergence issues. [^amber-dyes]: AMBER DYES two-stage RESP protocol ( bibliography/amber-dyes.pdf ), bundled with the repository for reference.","title":"Two-Step RESP Workflow"},{"location":"workflows/twostep-resp/#two-step-resp-workflow","text":"The two-step RESP pipeline reproduces the AMBER-style restrained electrostatic potential fit used by the TeraChem DYES protocol.[^amber-dyes] It applies the Weisfeiler\u2013Lehman symmetry buckets computed for each microstate, enforces total and bucket-specific charge constraints, and reruns a second RESP optimisation that selectively relaxes atoms flagged in project-specific masks.","title":"Two-Step RESP Workflow"},{"location":"workflows/twostep-resp/#stages-at-a-glance","text":"Linear warm start \u2013 solve_least_squares_with_constraints (in twostepresp.tsresp ) fits bucket charges that satisfy the aggregate constraints and provides an initial KKT solution. Step-one RESP \u2013 resp_step runs a Newton\u2013Krylov solve with the hyperbolic restraint active on the mask defined in mask_step_1.yaml , producing step1 charges for every configuration. Step-two RESP \u2013 The solver reuses converged bucket charges but frees the subset flagged in mask_step_2.yaml , recomputing the fit while holding the remaining buckets fixed. The result is stored as step2 , our recommended production charge set. Both RESP steps log the KKT residual, gradient norm, and the charge vector, matching the diagnostics in resp.resp .","title":"Stages at a Glance"},{"location":"workflows/twostep-resp/#command-line-entry-point","text":"scripts/generate_twostep_resp.py batches the workflow across all TeraChem configurations in a microstate directory: python scripts/generate_twostep_resp.py \\ --microstate-root data/microstates/PPP \\ --maxiter 400 The script automatically: Loads symmetry-buckets/r8.dat to build the expansion matrix. Reads total and bucket charge constraints from charge-contraints/ . Applies step-one and step-two masks from YAML templates co-located in the microstate root. Persists labels (configuration stems), step1 , and step2 matrices to twostepRESP/charges.npz . Use --dry-run to list the configuration stems without running RESP, or --max-configs to limit the number of fits during debugging.","title":"Command-Line Entry Point"},{"location":"workflows/twostep-resp/#retrying-a-single-configuration","text":"scripts/retry_twostep_resp.py mirrors the batch workflow for a single stem: python scripts/retry_twostep_resp.py \\ --microstate-root data/microstates/PPP \\ --config conf2371 \\ --step1-maxiter 120 \\ --step2-maxiter 240 \\ --show-charges The retrier reuses the masks, symmetry buckets, and constraints from the batch script, but exposes separate iteration limits for each stage and can print the atom-wise charges, making it ideal for diagnosing non-convergent fits.","title":"Retrying a Single Configuration"},{"location":"workflows/twostep-resp/#consuming-the-results","text":"The resulting NPZ files provide configuration-major charge matrices. Pair them with the atom labels from the raw ESP workflow to slice by atom type, compare against single-step RESP, or feed into downstream notebooks such as notebooks/twostepRESP.ipynb . Because step2 aligns with the AMBER two-stage procedure, it should be used as the primary source for production charge analyses unless diagnostics show step-two convergence issues. [^amber-dyes]: AMBER DYES two-stage RESP protocol ( bibliography/amber-dyes.pdf ), bundled with the repository for reference.","title":"Consuming the Results"}]}