{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"biliresp","text":"<p>Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for TeraChem, linear and hyperbolic solvers, two-step RESP workflows, and multi-configuration/multi-molecule pipelines.</p> <p>Use the navigation to find quick-start installation instructions and focused walkthroughs for the workflows:</p> <ul> <li>Fitting charges with the linear ESP solver.</li> <li>Two-step RESP with symmetry and charge constraints.</li> <li>Multi-configuration and multi-molecule RESP.</li> </ul> <p>Project layout:</p> <ul> <li><code>data/</code> holds inputs and parameters tied to a microstate (PDB, esp.xyz, resp.out, symmetry buckets).</li> <li><code>configs/</code> holds YAML run configurations and charge-constraint files.</li> <li><code>results/</code> holds outputs organized by microstate and function.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9+ (conda recommended, includes RDKit).</li> </ul>"},{"location":"getting-started/#install","title":"Install","text":"<pre><code>conda env create -f environment.yml\nconda activate biliresp\npython -m pip install -e .\n</code></pre>"},{"location":"getting-started/#run-the-test-suite","title":"Run the test suite","text":"<p>Run pytest from the repository root:</p> <pre><code>pytest -q\n</code></pre> <p>To run a single test module:</p> <pre><code>pytest -q tests/test_dipole.py\n</code></pre>"},{"location":"getting-started/#run-a-workflow","title":"Run a workflow","text":"<p>Create a config under <code>configs/&lt;microstate&gt;/&lt;function&gt;/config.yaml</code> and run:</p> <pre><code>biliresp --function twostepRESP_basic --yaml HID/twostepRESP_basic --slurm\n</code></pre> <p><code>--yaml</code> accepts a full path or a <code>configs/</code> subpath. With <code>--slurm</code>, the CLI writes a Slurm script under <code>results/slurm/</code> and submits it via <code>sbatch</code>.</p> <p>Use <code>--dry-run</code> to verify the resolved command without executing it:</p> <pre><code>biliresp --function twostepRESP_basic --yaml HID/twostepRESP_basic --dry-run\n</code></pre> <p>See <code>slurm-quickstart.md</code> for more detail.</p>"},{"location":"modules/","title":"Module Overview","text":"<p>This project is organized as a single package, <code>biliresp</code>, with focused submodules for parsing, fitting, and analysis. The table below summarizes the main modules and how they fit together.</p> Module Purpose Key Entrypoints <code>biliresp.resp_parser</code> Parse TeraChem <code>resp.out</code>, <code>esp.xyz</code>, and <code>.xyz</code> geometry frames. <code>ParseRespDotOut</code>, <code>ParseESPXYZ</code>, <code>ParseDotXYZ</code> <code>biliresp.linearESPcharges</code> Build Coulomb matrices and solve the linear (unrestrained) ESP fit. <code>prepare_linear_system</code>, <code>explicit_solution</code> <code>biliresp.resp</code> Single-frame RESP solver with hyperbolic restraint. <code>fit_resp_charges</code>, <code>kkt_residual_at</code> <code>biliresp.dipole</code> Dipole and center-of-mass helpers. <code>center_of_mass_bohr_from_xyz</code> <code>biliresp.symmetry</code> WL refinement and symmetry buckets for charge tying. <code>buckets_from_pdb</code> <code>biliresp.twostepresp_basic</code> Two-step RESP with total + bucket constraints. <code>resp_step</code>, <code>solve_least_squares_with_constraints</code> <code>biliresp.twostepresp_masked_total</code> Two-step RESP with a masked total-charge constraint. <code>load_total_constraint</code>, <code>build_total_constraint_mask</code> <code>biliresp.twostepresp_group_constraints</code> Two-step RESP with group constraints (no implicit total). <code>load_group_constraints</code> <code>biliresp.twostepresp_frozen_buckets</code> Two-step RESP with frozen bucket values. <code>load_frozen_buckets</code> <code>biliresp.multiconfresp</code> Multi-configuration assembly for a microstate. <code>mcresp.py</code> CLI <code>biliresp.reduced_basic</code> Reduced-space RESP solver (total + bucket constraints). <code>reduced.py</code> CLI <code>biliresp.reduced_masked_total</code> Reduced-space solver with masked total constraint. <code>reduced.py</code> CLI <code>biliresp.reduced_group_constraints</code> Reduced-space solver with group constraints. <code>reduced.py</code> CLI <code>biliresp.multimoleculeresp</code> Multi-molecule, multi-config RESP (global buckets + optional freezing). <code>mmresp.py</code> CLI <p>For recipes and command-line workflows, see the pages under Workflows.</p>"},{"location":"slurm-quickstart/","title":"Slurm Quickstart","text":"<p>This project provides a CLI that can submit RESP workflows to Slurm. The CLI reads a YAML config, builds the right command, writes a Slurm script under <code>results/slurm/</code>, and submits it via <code>sbatch</code>.</p>"},{"location":"slurm-quickstart/#1-prepare-inputs","title":"1) Prepare inputs","text":"<p>Place your inputs under <code>data/microstates/&lt;MICROSTATE&gt;/</code>:</p> <ul> <li><code>&lt;MICROSTATE&gt;.pdb</code></li> <li><code>symmetry-buckets/r8.dat</code></li> <li><code>terachem/espxyz/*.esp.xyz</code></li> <li><code>terachem/respout/*.resp.out</code></li> </ul> <p>See the minimal example layout in <code>docs/examples/microstates/</code>.</p> <p>If you only have raw TeraChem outputs under a <code>raw_terachem_outputs/</code> directory, use:</p> <pre><code>biliresp --process data/microstates/&lt;MICROSTATE&gt;\n</code></pre> <p>To override the raw subdirectory name:</p> <pre><code>biliresp --process data/microstates/&lt;MICROSTATE&gt; --tc-raw-subdir raw_tc\n</code></pre>"},{"location":"slurm-quickstart/#2-create-a-config","title":"2) Create a config","text":"<p>Create <code>configs/&lt;microstate&gt;/&lt;function&gt;/config.yaml</code>. Example:</p> <pre><code>microstate: HID\nargs:\n  frame: -1\n  maxiter: 400\nslurm:\n  time: \"24:00:00\"\n  mem: \"64G\"\n  cpus_per_task: 12\n</code></pre> <p>A complete example config is in <code>docs/examples/configs/</code>.</p>"},{"location":"slurm-quickstart/#3-dry-run-recommended","title":"3) Dry run (recommended)","text":"<p>Use <code>--dry-run</code> to see the resolved command and config path before submitting:</p> <pre><code>biliresp --function twostepRESP_basic --yaml HID/twostepRESP_basic --dry-run\n</code></pre>"},{"location":"slurm-quickstart/#4-submit-to-slurm","title":"4) Submit to Slurm","text":"<pre><code>biliresp --function twostepRESP_basic --yaml HID/twostepRESP_basic --slurm\n</code></pre> <p>This writes a script under <code>results/slurm/</code> and submits it with <code>sbatch</code>.</p>"},{"location":"slurm-quickstart/#slurm-settings","title":"Slurm settings","text":"<p>You can override these keys under <code>slurm:</code> in the config:</p> <ul> <li><code>job_name</code></li> <li><code>output</code> / <code>error</code></li> <li><code>time</code></li> <li><code>nodes</code></li> <li><code>cpus_per_task</code></li> <li><code>mem</code></li> <li><code>partition</code></li> <li><code>account</code></li> <li><code>mail_type</code> / <code>mail_user</code></li> </ul> <p>The template loads <code>anaconda</code>, activates the <code>biliresp</code> conda env, and sets <code>PYTHONPATH</code> to the project <code>src/</code> directory.</p>"},{"location":"symmetry/","title":"Symmetry Analysis","text":"<p>The symmetry module converts molecular structures into <code>networkx</code> graphs and applies Weisfeiler\u2013Lehman (WL) refinement to discover atoms that share identical local environments. This is particularly helpful when analysing RESP results, because the buckets returned by the WL procedure highlight atoms that can share constrained charges.</p> <pre><code>from pathlib import Path\n\nfrom biliresp.symmetry import buckets_from_pdb\n\nbuckets = buckets_from_pdb(Path(\"data/raw/1.pose.pdb\"), radius=10)\nprint(f\"Identified {len(buckets)} equivalence classes\")\n</code></pre> <p>Each bucket contains the indices of atoms that are indistinguishable after <code>r</code> rounds of WL refinement. Increase <code>radius</code> when you need a deeper comparison of atomic environments.</p> <p></p> <p>Hydrogen-less molecular network used for WL refinement.</p> Radius 10 Radius 15 <p>The figure above starts from the hydrogen-less network of the biliverdin fragment. The colourings correspond to WL buckets evaluated at radii 10 and 15, respectively.</p>"},{"location":"examples/microstates/HID/","title":"Minimal microstate example (HID)","text":"<p>This folder illustrates the required inputs for a microstate. These files are placeholders and are not meant for real RESP fitting. Replace them with your real data under <code>data/microstates/</code>.</p> <p>Expected layout:</p> <ul> <li><code>HID.pdb</code></li> <li><code>symmetry-buckets/r8.dat</code></li> <li><code>terachem/espxyz/conf0.esp.xyz</code></li> <li><code>terachem/respout/conf0.resp.out</code></li> </ul>"},{"location":"workflows/dipole-cross-validation/","title":"Dipole Cross-Validation","text":"<p>The helper implemented in <code>scripts/print_dipoles.py</code> (and mirrored inside <code>tests/test_dipole.py</code>) compares three sets of dipole moments for a selected frame of a RESP run:</p> <ol> <li>QM dipole reported directly by TeraChem.</li> <li>TeraChem dipole reconstructed from the ESP-unrestrained charges written in <code>resp.out</code>.</li> <li>Lagrange dipole generated from the fitted charges returned by the linear ESP solver.</li> </ol> <p>The helper parses the frame in <code>resp.out</code>, converts the logged center of mass to bohr, and computes dipoles in Debye via:</p> \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] <p>with coordinates expressed in bohr. It also reports a mass-weighted center of mass derived from the supplied geometry <code>.xyz</code> file; you can override the coordinates (\u00c5 or bohr) when calling <code>center_of_mass_bohr_from_xyz</code> if you need to reuse RESP geometries directly. The return dictionary contains each dipole vector/magnitude, their deltas relative to the QM reference, and both COM estimates.</p>"},{"location":"workflows/dipole-cross-validation/#script-entry-point","title":"Script entry point","text":"<p><code>scripts/print_dipoles.py</code> bundles the full workflow:</p> <pre><code>python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz data/raw/1.pose.xyz 78 --frame -1\n</code></pre> <ul> <li>The script builds the linear system, fits charges with the explicit Lagrange projection, and prints the QM, TeraChem, and Lagrange dipoles plus their deltas.</li> <li><code>--frame</code> chooses which RESP frame to analyze (<code>-1</code> = last). The geometry <code>.xyz</code> supplies element ordering for mass lookup when computing the mass-weighted COM.</li> </ul>"},{"location":"workflows/dipole-cross-validation/#typical-output","title":"Typical output","text":"<pre><code>QM (from resp.out log)\n  vector (Debye): [-0.123 ...]\n  |\u03bc| (Debye):   2.345678\n\nTerachem charges (RESP log)\n  vector (Debye): [-0.121 ...]\n  |\u03bc| (Debye):   2.346100\n  \u0394 vector vs QM (Debye): [0.002 ...]\n  \u0394|\u03bc| vs QM (Debye):     0.000422\n\nLagrange multiplier fit (explicit)\n  vector (Debye): [-0.120 ...]\n  |\u03bc| (Debye):   2.345900\n  \u0394 vector vs QM (Debye): [0.003 ...]\n  \u0394|\u03bc| vs QM (Debye):     0.000222\n</code></pre> <p>Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows.</p>"},{"location":"workflows/dipole-cross-validation/#parity-visualisation","title":"Parity visualisation","text":"<p>The example notebook in <code>notebooks/</code> produces a parity plot comparing the QM dipole magnitude against the TeraChem ESP reconstruction across every frame. The figure below highlights the excellent agreement and annotates the RMSE.</p> <p></p> <p>Colours denote the absolute deviation |\u0394| in Debye.</p>"},{"location":"workflows/dipole-cross-validation/#programmatic-use","title":"Programmatic use","text":"<p>See <code>tests/test_dipole.py</code> for a complete, importable example. The test implements <code>_three_dipoles_for_frame</code> inline so you can copy it into your own workflow if the CLI output is not sufficient.</p>"},{"location":"workflows/esp-charge-distributions/","title":"ESP Charge Distributions","text":"<p>The notebook in <code>notebooks/</code> that accompanies this project aggregates the ESP-unrestrained charges from every frame in <code>resp.out</code>. Two views are especially useful when sanity-checking how individual atoms sample the RESP charge distribution throughout a trajectory.</p>"},{"location":"workflows/esp-charge-distributions/#per-atom-histograms","title":"Per-atom histograms","text":"<p>The figure below overlays the histograms for every nitrogen (blue tones) and oxygen (orange tones) atom. Each trace corresponds to one atom index, so you can spot outliers or unusually broad distributions at a glance.</p> <p></p> <p>The compact support and narrow widths suggest that the ESP-unrestrained fit is stable across the frames considered.</p>"},{"location":"workflows/esp-charge-distributions/#gaussian-fits","title":"Gaussian fits","text":"<p>The same notebook fits a normal distribution to each atom\u2019s samples and overlays the resulting curves. This makes it easy to compare the mean and spread across similar atoms.</p> <p></p> <p>The legend in the notebook lists the fitted mean (\u03bc) and standard deviation (\u03c3) for each atom, providing quick access to quantitative summaries that can be reused in downstream analyses.</p>"},{"location":"workflows/linear-esp-solver/","title":"Linear ESP Charge Solver","text":"<p>The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in <code>biliresp.linearESPcharges.linear</code> and is backed by numpy.</p>"},{"location":"workflows/linear-esp-solver/#pipeline","title":"Pipeline","text":"<ol> <li>Parse Terachem RESP output with <code>ParseRespDotOut</code> (from <code>biliresp.resp_parser</code>) to obtain atomic positions and RESP ESP charges for each frame.</li> <li>Read ESP grid points from <code>esp.xyz</code>.</li> <li>Build the design matrix <code>A</code> where <code>A[i, j] = 1 / r_ij</code> for grid point <code>i</code> and atom <code>j</code>.</li> <li>Solve the constrained optimization problem <code>A q \u2248 V</code> subject to <code>\u03a3 q = Q</code> with <code>explicit_solution</code>, a closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). It accepts an optional <code>ridge</code> hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability.</li> </ol>"},{"location":"workflows/linear-esp-solver/#script-entry-point","title":"Script entry point","text":"<p>The <code>scripts/compare_charges.py</code> wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges:</p> <pre><code>python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1\n</code></pre> <ul> <li><code>resp.out</code>: RESP log file containing the ESP unrestrained block.</li> <li><code>esp.xyz</code>: grid potentials from TeraChem.</li> <li><code>78</code>: number of atoms in the RESP job.</li> <li><code>--frame</code>: zero-based frame index (use <code>-1</code> for the last frame).</li> <li>The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality.</li> </ul>"},{"location":"workflows/linear-esp-solver/#mathematical-derivation","title":"Mathematical derivation","text":"<p>The objective is to minimise the grid misfit while enforcing the desired total charge:</p> \\[ \\begin{aligned} \\min_{q}\\ &amp; \\frac{1}{2}\\lVert A q - V \\rVert_2^2 \\\\ \\text{s.t.}\\ &amp; \\mathbf{1}^\\top q = Q. \\end{aligned} \\] <p>Using the Lagrangian \\(\\mathcal{L}(q, \\lambda) = \\tfrac{1}{2}\\lVert A q - V \\rVert_2^2 + \\lambda (\\mathbf{1}^\\top q - Q)\\) gives the stationary conditions</p> \\[ \\nabla_q \\mathcal{L} = A^\\top(Aq - V) + \\lambda\\,\\mathbf{1} = 0,\\qquad \\nabla_\\lambda \\mathcal{L} = \\mathbf{1}^\\top q - Q = 0. \\] <p>Defining \\(H = A^\\top A\\) and \\(g = A^\\top V\\) leads to the Karush\u2013Kuhn\u2013Tucker system</p> \\[ \\begin{pmatrix} H &amp; \\mathbf{1} \\\\ \\mathbf{1}^\\top &amp; 0 \\end{pmatrix} \\begin{pmatrix} q \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} g \\\\ Q \\end{pmatrix}. \\] <p>Rather than solving the \\((N+1)\\times(N+1)\\) block system directly, the implementation projects the unconstrained least-squares solution onto the charge-conserving hyperplane:</p> <ol> <li>Solve \\(H q_0 = g\\) to obtain the unconstrained solution (<code>q0</code>).</li> <li>Solve \\(H c = \\mathbf{1}\\) for the correction direction (<code>c</code>).</li> <li>Compute \\(\\alpha = \\mathbf{1}^\\top c\\) and \\(s = \\mathbf{1}^\\top q_0\\).</li> <li>Project: \\(q = q_0 - \\frac{s - Q}{\\alpha}\\, c\\).</li> </ol> <p>If numerical damping is requested, \\(H\\) is replaced with \\(H + \\eta I\\) (with a small \\(\\eta &gt; 0\\)) in the two linear solves above. The procedure yields the same result as the full KKT solve but avoids explicitly forming the block matrix.</p>"},{"location":"workflows/linear-esp-solver/#programmatic-use","title":"Programmatic use","text":"<p>You can access the components directly:</p> <pre><code>from biliresp.linearESPcharges.linear import prepare_linear_system, explicit_solution\n\nA, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1)\nsolver = explicit_solution(ridge=0.0)\nresult = solver.fit(A, V, Q)\nprint(result[\"rmse\"], result[\"sum_q\"])\n</code></pre> <p>The returned dictionary includes the fitted charges <code>q</code>, intermediate matrices, RMSE/RRMS, and the enforced total charge.</p>"},{"location":"workflows/multiconf-resp/","title":"Multiconfiguration RESP (Ensemble)","text":"<p>The multiconfiguration workflow stacks multiple conformations of a single microstate into one large ESP fitting problem. It is useful when you want charges that best represent an ensemble rather than a single conformer.</p>"},{"location":"workflows/multiconf-resp/#assemble-and-run","title":"Assemble and Run","text":"<p>The CLI lives in <code>biliresp.multiconfresp.mcresp</code>.</p> <pre><code>python -m biliresp.multiconfresp.mcresp \\\n  --microstate PPP \\\n  --load-and-resp \\\n  --maxiter 400\n</code></pre> <p>Under the hood this:</p> <ul> <li>Reads <code>data/microstates/&lt;microstate&gt;/terachem/respout/*.resp.out</code> and <code>espxyz/*.esp.xyz</code>.</li> <li>Stacks the Coulomb matrices and ESP vectors across all configurations.</li> <li>Runs the two-step RESP solver (basic variant) over the stacked system.</li> </ul>"},{"location":"workflows/multiconf-resp/#output","title":"Output","text":"<p>For ensemble runs the default outputs are written under:</p> <pre><code>results/&lt;microstate&gt;/multiconfRESP/\n</code></pre> <p>If you are using a reduced-space variant, see Reduced RESP for the alternative output directories.</p>"},{"location":"workflows/multimolecule-resp/","title":"Multi-Molecule RESP","text":"<p>The multi-molecule workflow (<code>biliresp.multimoleculeresp.mmresp</code>) fits charges across multiple microstates at once. It supports global symmetry buckets that tie atoms across molecules, optional frozen buckets, and per-molecule total or group constraints.</p>"},{"location":"workflows/multimolecule-resp/#run-from-a-manifest","title":"Run from a Manifest","text":"<pre><code>python -m biliresp.multimoleculeresp.mmresp \\\n  --manifest configs/manifest_hist.yaml \\\n  --output results/mmresp_hist/charges.npz \\\n  --ridge 1e-6\n</code></pre> <p>The manifest defines:</p> <ul> <li>A list of molecules, each with paths to Coulomb matrices and ESP vectors.</li> <li>Global symmetry buckets (optional), including target charges or frozen values.</li> <li>Per-molecule constraints (total or group constraints).</li> </ul>"},{"location":"workflows/multimolecule-resp/#bootstrap-workflows","title":"Bootstrap Workflows","text":"<p>Two helper scripts generate bootstrap matrices and manifests:</p> <ul> <li><code>scripts/bootstrap_hist.py</code> \u2013 deterministic leave-two-out subsets.</li> <li><code>scripts/bootstrap_hist_random.py</code> \u2013 random resampling with replacement.</li> </ul> <p>These are paired with the <code>run_bootstrap_*.slurm</code> scripts for cluster runs.</p>"},{"location":"workflows/reduced-resp/","title":"Reduced-Space RESP","text":"<p>Reduced-space solvers enforce the linear constraints exactly by projecting into the nullspace of the constraint matrix. These are useful for large ensemble fits where a direct KKT solve is unstable.</p>"},{"location":"workflows/reduced-resp/#variants","title":"Variants","text":"<ul> <li>Basic \u2013 total + bucket constraints: <code>biliresp.reduced_basic</code></li> <li>Masked total \u2013 total charge applied to a subset: <code>biliresp.reduced_masked_total</code></li> <li>Group constraints \u2013 arbitrary group targets: <code>biliresp.reduced_group_constraints</code></li> </ul>"},{"location":"workflows/reduced-resp/#example","title":"Example","text":"<pre><code>python -m biliresp.reduced_group_constraints.reduced \\\n  --microstate HID \\\n  --load-and-resp \\\n  --input-dir-name multiconfRESP \\\n  --output-dir-name multiconfRESP_reduced_group_constraints\n</code></pre> <p>The outputs are written under <code>results/&lt;microstate&gt;/</code> in the selected output directory.</p>"},{"location":"workflows/resp-hyperbolic-solver/","title":"RESP Hyperbolic Solver","text":"<p>The RESP workflow augments the linear ESP fit with a nonlinear, hyperbolic restraint that mirrors the setup used by TeraChem. All routines live in <code>biliresp.resp.resp</code>, with <code>fit_resp_charges</code> acting as the main entry point.</p>"},{"location":"workflows/resp-hyperbolic-solver/#objective-and-restraint","title":"Objective and Restraint","text":"<p>Given a design matrix \\(A \\in \\mathbb{R}^{M \\times N}\\), ESP grid values \\(V \\in \\mathbb{R}^{M}\\), and a target total charge \\(Q\\), we minimise the penalised loss</p> \\[ \\mathcal{L}(q) = \\|A q - V\\|_2^2 + R(q), \\] <p>subject to charge conservation</p> \\[ \\mathbf{1}^\\top q = Q. \\] <p>The restraint couples to a mask \\(m \\in \\{0,1\\}^N\\) that selects which atoms participate (all atoms by default):</p> \\[ R(q) = a \\sum_{i: m_i = 1} \\left(\\sqrt{(q_i - q_0)^2 + b^2} - b\\right). \\] <p>Parameters \\((a, b, q_0)\\) form the <code>HyperbolicRestraint</code>. The gradient needed for optimisation is</p> \\[ \\frac{\\partial R}{\\partial q_i} = \\begin{cases} a\\,\\dfrac{q_i - q_0}{\\sqrt{(q_i - q_0)^2 + b^2}}, &amp; m_i = 1,\\\\[1.2ex] 0, &amp; m_i = 0. \\end{cases} \\]"},{"location":"workflows/resp-hyperbolic-solver/#kkt-system","title":"KKT System","text":"<p>Introducing a Lagrange multiplier \\(\\lambda\\) for the charge constraint yields the first-order optimality conditions</p> \\[ \\nabla_q \\mathcal{L}(q) + \\lambda \\mathbf{1} = 0, \\qquad \\mathbf{1}^\\top q - Q = 0, \\] <p>where \\(\\nabla_q \\mathcal{L}(q) = 2 A^\\top (A q - V) + \\nabla R(q)\\).</p> <p>Stacking the unknowns into \\(x = (q, \\lambda)\\) gives a nonlinear system</p> \\[ F(x) = \\begin{bmatrix} 2 A^\\top (A q - V) + \\nabla R(q) + \\lambda \\mathbf{1} \\\\ \\mathbf{1}^\\top q - Q \\end{bmatrix} = 0. \\]"},{"location":"workflows/resp-hyperbolic-solver/#newtonkrylov-solve","title":"Newton\u2013Krylov Solve","text":"<p><code>fit_resp_charges</code> calls SciPy's <code>newton_krylov</code> on \\(F(x)\\). The solver uses an initial guess \\((q^{(0)}, \\lambda^{(0)})\\) built from the linear ESP solution and zero Lagrange multiplier. Each iteration:</p> <ol> <li>Evaluates \\(F(x)\\) and numerically approximates the Jacobian\u2013vector product.</li> <li>Solves for a correction using a Krylov subspace method.</li> <li>Updates \\(x\\) with the computed Newton step.</li> </ol> <p>No line search is performed, so the loss history can oscillate slightly before convergence. Convergence is declared when the infinity norm of \\(F(x)\\) drops below the requested tolerance.</p>"},{"location":"workflows/resp-hyperbolic-solver/#diagnostics-and-outputs","title":"Diagnostics and Outputs","text":"<ul> <li>The returned dictionary includes the fitted charges, Lagrange multiplier, loss breakdown (<code>loss</code>, <code>ls_term</code>, <code>restraint</code>), RMSE/RRMS, total charge information, the boolean restraint mask, and the running <code>loss_history</code>.</li> <li><code>_loss_terms</code> evaluates the same objective outside the solver loop and is reused by the public API for consistency.</li> <li><code>kkt_residual_at</code> re-computes \\(F(x)\\) for any charge vector, making it easy to compare against reference data such as TeraChem outputs or to audit convergence criteria.</li> <li><code>plot_loss_history</code> visualises <code>loss_history</code>. If <code>notebooks/prl.mplstyle</code> exists, it is applied automatically to keep project plots consistent; otherwise the Matplotlib defaults are used.</li> </ul>"},{"location":"workflows/resp-hyperbolic-solver/#masking-behaviour","title":"Masking Behaviour","text":"<p>By default every atom is restrained. Passing <code>restrain_all_atoms=False</code> selects only heavy atoms, reproducing the legacy RESP convention. The solver stores the mask used in the <code>mask</code> entry of the result bundle.</p>"},{"location":"workflows/resp-hyperbolic-solver/#usage-example","title":"Usage Example","text":"<pre><code>from pathlib import Path\nfrom biliresp.resp.resp import HyperbolicRestraint, fit_resp_charges\n\nresp_out = Path(\"data/raw/resp.out\")\nesp_xyz = Path(\"data/raw/esp.xyz\")\ngeometry_xyz = Path(\"data/raw/1.pose.xyz\")\n\nrestraint = HyperbolicRestraint(a=5e-4, b=1e-3, q0=0.0)\nresult = fit_resp_charges(\n    resp_out,\n    esp_xyz,\n    geometry_xyz,\n    number_of_atoms=78,\n    frame_index=-1,\n    restraint=restraint,\n    restrain_all_atoms=True,\n    save_loss_plot=True,\n)\n\nprint(result[\"loss\"], result[\"sum_q\"])\n</code></pre> <p>This mirrors the workflow exercised in <code>tests/test_resp_solver.py</code>, where the fitted charges match the final RESP frame from TeraChem to within \\(10^{-5}\\).</p>"},{"location":"workflows/terachem-processing/","title":"Raw TeraChem Processing","text":"<p>Most users should run TeraChem RESP jobs with <code>biliresp --run-tc-resp</code>, then collect outputs with:</p> <pre><code>biliresp --process-tc-resp data/microstates/&lt;MICROSTATE&gt;\n</code></pre> <p>This gathers <code>resp.out</code> plus the scratch <code>esp.xyz</code> files and writes the standardized inputs under <code>data/microstates/&lt;MICROSTATE&gt;/terachem/</code>.</p>"},{"location":"workflows/terachem-processing/#required-raw-layout","title":"Required raw layout","text":"<p>Place raw outputs under:</p> <pre><code>data/microstates/&lt;MICROSTATE&gt;/raw_terachem_outputs/\n</code></pre> <p>Expected structure:</p> <pre><code>raw_terachem_outputs/\n  confs/\n    conf_001/\n      resp.out\n      scr.&lt;rst7_file_name&gt;/esp.xyz\n    conf_002/\n      resp.out\n      scr.&lt;rst7_file_name&gt;/esp.xyz\n</code></pre>"},{"location":"workflows/terachem-processing/#outputs","title":"Outputs","text":"<p>The command writes:</p> <pre><code>data/microstates/&lt;MICROSTATE&gt;/terachem/respout/conf####.resp.out\ndata/microstates/&lt;MICROSTATE&gt;/terachem/espxyz/conf####.esp.xyz\n</code></pre>"},{"location":"workflows/terachem-processing/#next-step","title":"Next step","text":"<p>Once processed, proceed to the RESP workflows (two-step, multiconf, reduced, etc.) using the standard configs under <code>configs/</code>.</p>"},{"location":"workflows/terachem-run/","title":"TeraChem RESP Job Submission","text":"<p>This workflow writes TeraChem input files (<code>resp.in</code>), generates Slurm submission scripts, and submits jobs for each configuration under a microstate.</p>"},{"location":"workflows/terachem-run/#expected-inputs","title":"Expected inputs","text":"<pre><code>data/microstates/&lt;MICROSTATE&gt;/input_tc_structures/confs/&lt;conf&gt;/parm7\ndata/microstates/&lt;MICROSTATE&gt;/input_tc_structures/confs/&lt;conf&gt;/rst7\nconfigs/&lt;MICROSTATE&gt;/input_tc_structures/&lt;conf&gt;/config.yaml\n</code></pre> <p>Each <code>config.yaml</code> provides the TeraChem settings, including the charge:</p> <pre><code>charge: 1\nbasis: 6-31gs\nmethod: rhf\nspinmult: 1\nmaxit: 1000\nrun: energy\nresp: yes\nesp_grid_dens: 4.0\n</code></pre>"},{"location":"workflows/terachem-run/#run","title":"Run","text":"<pre><code>biliresp --run-tc-resp data/microstates/&lt;MICROSTATE&gt;\n</code></pre> <p>For each conf, the module writes:</p> <ul> <li><code>resp.in</code></li> <li><code>run_tc_resp.slurm</code></li> <li><code>nowater.parm7</code> / <code>nowater.rst7</code> (copies of the provided files)</li> </ul> <p>Then it submits <code>sbatch run_tc_resp.slurm</code> immediately.</p>"},{"location":"workflows/terachem-run/#collect-outputs-for-resp-workflows","title":"Collect outputs for RESP workflows","text":"<p>TeraChem writes <code>resp.out</code> in the conf directory and <code>esp.xyz</code> under a scratch folder named <code>scr.&lt;rst7&gt;</code>. Once the jobs finish, collect outputs into the standard layout:</p> <pre><code>biliresp --process-tc-resp data/microstates/&lt;MICROSTATE&gt;\n</code></pre> <p>This writes:</p> <pre><code>data/microstates/&lt;MICROSTATE&gt;/terachem/respout/conf####.resp.out\ndata/microstates/&lt;MICROSTATE&gt;/terachem/espxyz/conf####.esp.xyz\n</code></pre>"},{"location":"workflows/twostep-resp/","title":"Two-Step RESP Workflow","text":"<p>The two-step RESP pipeline reproduces the AMBER-style restrained electrostatic potential fit used by the TeraChem <code>DYES</code> protocol.[^amber-dyes] It applies the Weisfeiler\u2013Lehman symmetry buckets computed for each microstate, enforces total and bucket-specific charge constraints, and reruns a second RESP optimisation that selectively relaxes atoms flagged in project-specific masks.</p>"},{"location":"workflows/twostep-resp/#stages-at-a-glance","title":"Stages at a Glance","text":"<ol> <li>Linear warm start \u2013 <code>solve_least_squares_with_constraints</code> (in <code>biliresp.twostepresp_basic.tsresp</code>) fits bucket charges that satisfy the aggregate constraints and provides an initial KKT solution.</li> <li>Step-one RESP \u2013 <code>resp_step</code> runs a Newton\u2013Krylov solve with the hyperbolic restraint active on the mask defined in <code>mask_step_1.yaml</code>, producing <code>step1</code> charges for every configuration.</li> <li>Step-two RESP \u2013 The solver reuses converged bucket charges but frees the subset flagged in <code>mask_step_2.yaml</code>, recomputing the fit while holding the remaining buckets fixed. The result is stored as <code>step2</code>, our recommended production charge set.</li> </ol> <p>Both RESP steps log the KKT residual, gradient norm, and the charge vector, matching the diagnostics in <code>resp.resp</code>.</p>"},{"location":"workflows/twostep-resp/#command-line-entry-point","title":"Command-Line Entry Point","text":"<p><code>scripts/generate_twostep_resp.py</code> batches the workflow across all TeraChem configurations in a microstate directory:</p> <pre><code>python scripts/generate_twostep_resp.py \\\n  --microstate-root data/microstates/PPP \\\n  --maxiter 400\n</code></pre> <p>The script automatically:</p> <ul> <li>Loads <code>symmetry-buckets/r8.dat</code> to build the expansion matrix.</li> <li>Reads total and bucket charge constraints from <code>charge-contraints/</code>.</li> <li>Applies step-one and step-two masks from YAML templates co-located in the microstate root.</li> <li>Persists <code>labels</code> (configuration stems), <code>step1</code>, and <code>step2</code> matrices to <code>results/&lt;microstate&gt;/twostepRESP_basic/charges.npz</code>.</li> </ul> <p>Use <code>--dry-run</code> to list the configuration stems without running RESP, or <code>--max-configs</code> to limit the number of fits during debugging.</p>"},{"location":"workflows/twostep-resp/#retrying-a-single-configuration","title":"Retrying a Single Configuration","text":"<p><code>scripts/retry_twostep_resp.py</code> mirrors the batch workflow for a single stem:</p> <pre><code>python scripts/retry_twostep_resp.py \\\n  --microstate-root data/microstates/PPP \\\n  --config conf2371 \\\n  --step1-maxiter 120 \\\n  --step2-maxiter 240 \\\n  --show-charges\n</code></pre> <p>The retrier reuses the masks, symmetry buckets, and constraints from the batch script, but exposes separate iteration limits for each stage and can print the atom-wise charges, making it ideal for diagnosing non-convergent fits.</p>"},{"location":"workflows/twostep-resp/#variants","title":"Variants","text":"<p>The project ships specialized two-step RESP variants for different constraint setups:</p> <ul> <li>Masked total constraint \u2013 <code>scripts/generate_twostep_resp_masked_total.py</code> writes to <code>results/&lt;microstate&gt;/twostepRESP_masked_total/</code>.</li> <li>Group constraints \u2013 <code>scripts/generate_twostep_resp_group_constraints.py</code> writes to <code>results/&lt;microstate&gt;/twostepRESP_group_constraints/</code>.</li> <li>Frozen buckets \u2013 <code>scripts/generate_twostep_resp_frozen_buckets.py</code> writes to <code>results/&lt;microstate&gt;/twostepRESP_frozen_buckets/</code>.</li> </ul>"},{"location":"workflows/twostep-resp/#consuming-the-results","title":"Consuming the Results","text":"<p>The resulting NPZ files provide configuration-major charge matrices. Pair them with the atom labels from the raw ESP workflow to slice by atom type, compare against single-step RESP, or feed into downstream notebooks such as <code>notebooks/twostepRESP_basic.ipynb</code>. Because <code>step2</code> aligns with the AMBER two-stage procedure, it should be used as the primary source for production charge analyses unless diagnostics show step-two convergence issues.</p> <p>[^amber-dyes]: AMBER DYES two-stage RESP protocol (<code>bibliography/amber-dyes.pdf</code>), bundled with the repository for reference.</p>"}]}